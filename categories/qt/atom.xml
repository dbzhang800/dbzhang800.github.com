<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Qt | 1+1=2]]></title>
  <link href="http://blog.debao.me/categories/qt/atom.xml" rel="self"/>
  <link href="http://blog.debao.me/"/>
  <updated>2013-07-09T11:38:44+08:00</updated>
  <id>http://blog.debao.me/</id>
  <author>
    <name><![CDATA[Debao Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Link Confilict between SDL and Qt under Windows]]></title>
    <link href="http://blog.debao.me/2013/07/link-confilict-between-sdl-and-qt-under-windows/"/>
    <updated>2013-07-09T09:22:00+08:00</updated>
    <id>http://blog.debao.me/2013/07/link-confilict-between-sdl-and-qt-under-windows</id>
    <content type="html"><![CDATA[<p>Someone complain that, when using SDL and Qt in the same project under Windows, the linker will generate link error.</p>

<blockquote><p>SDLmain.lib(SDL_win32_main.obj):-1: error: LNK2005: _WinMain@16 already defined in qtmaind.lib(qtmain_win.obj)</p></blockquote>

<p>What happened behined this?</p>

<p>```</p>

<h1>include <QApplication></h1>

<h1>include &lt;SDL.h></h1>

<p>int main(int argc, char** argv)
{
return 0;
}
```</p>

<h2>WinMain vs main</h2>

<p>The C and C++ standards require any program to have a function called <em>main</em>, which serves as the program's startup function. It can have one of the following signatures:</p>

<p><code>
int main()
int main(int argc, char* argv[])
</code></p>

<p>However, <em>WinMain</em> is selected by Microsoft as the conventional name used for the GUI application entry point.</p>

<p><code>
int CALLBACK WinMain(
  _In_  HINSTANCE hInstance,
  _In_  HINSTANCE hPrevInstance,
  _In_  LPSTR lpCmdLine,
  _In_  int nCmdShow
);
</code></p>

<p>As a crossplatform library, both SDL and Qt don't require user to use the <em>WinMain</em> function to create GUI application for Windows. Instead, they both provided a <strong>WinMain()</strong> for us.</p>

<h2>WinMain provided by Qt</h2>

<h3>qtmain.lib provided by Qt</h3>

<p>As a Qt developer, we all know that, when ceating a GUI application under windows. qtmain.lib(or libqtmain.a) will be linked to the application.</p>

<p>If we open the source file of the library, we can see that our <em>main()</em> entry is called by a wrapped function WinMain()</p>

<p>```cpp  %QTDIR%/src/winmain/qtmain_win.cpp
/<em>
  WinMain() - Initializes Windows and calls user's startup function main().
  NOTE: WinMain() won't be called if the application was linked as a "console"
  application.
</em>/</p>

<p>extern "C"
int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prevInstance, LPSTR, int cmdShow)
{
...</p>

<pre><code>int result = main(argc, argv.data());
</code></pre>

<p>...
}
```</p>

<p>Very insteresting, isn't it? But</p>

<h3>This work well for MSVC though, but not for MinGW</h3>

<p>Consider we have a simple windows application which contians both main() and WinMain()</p>

<p>```cpp</p>

<h1>include &lt;windows.h></h1>

<p>int main()
{
  MessageBoxW (NULL, L"Hello World from main!", L"hello", MB_OK | MB_ICONINFORMATION);
  return 0;
}</p>

<p>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPTSTR lpCmdLine, int nShowCmd)
{
  MessageBoxW (NULL, L"Hello World from WinMain!", L"hello", MB_OK | MB_ICONINFORMATION);
  return 0;
}
<code>
* For MSVC, WinMain() or main() will be used depending on whether</code>/entry:WinMainCRTStartup``` is passed to the linker or not.
* For MinGW, WinMain() will never be called if main() exists!</p>

<h3>How to solve this problem for MinGW</h3>

<p>Let's see what happened when build a Qt Gui application under Windows.</p>

<p>In Qt souce file qwindowdefs.h or qtmain_win.cpp, we can find following code.
```cpp</p>

<h1>if defined(QT_NEEDS_QMAIN)</h1>

<h1>define main qMain</h1>

<h1>endif</h1>

<p>```</p>

<p>So <em>main()</em> doesn't exist any more when QT_NEEDS_QMAIN is defined!</p>

<h3>What happened for Gui Application?</h3>

<p>We know that,</p>

<p><code>
CONFIG += windows
</code>
is the default config of qmake, and that's why we have to add</p>

<p><code>
CONFIG += console
</code></p>

<p>if when want to create a mormal console application.</p>

<p>The former will force the qmake to load a feature file called <em>windows.prf</em>, in which we can find fowllowing code:</p>

<p>```
CONFIG -= console
contains(TEMPLATE, ".*app"){</p>

<pre><code>QMAKE_LFLAGS += $$QMAKE_LFLAGS_WINDOWS
win32-g++:DEFINES += QT_NEEDS_QMAIN
win32-borland:DEFINES += QT_NEEDS_QMAIN

qt:for(entryLib, $$list($$unique(QMAKE_LIBS_QT_ENTRY))) {
    isEqual(entryLib, -lqtmain): {
        CONFIG(debug, debug|release): QMAKE_LIBS += $${entryLib}$${QT_LIBINFIX}d
        else: QMAKE_LIBS += $${entryLib}$${QT_LIBINFIX}
    } else {
        QMAKE_LIBS += $${entryLib}
    }
}
</code></pre>

<p>}
```
As you can see, three things done here:</p>

<ul>
<li>Windows subsystem instead of console subsystem is linked, so no black-cmd-window will be shown when the application running. Note that, <code>$$QMAKE_LFLAGS_WINDOWS</code> will be expanded to <code>/subsystem:windows</code> or <code>-Wl,-subsystem,windows</code>.</li>
<li><code>QT_NEEDS_QMAIN</code> is defined for MinGW, so main() will be renamed to qMain which will be called by WinMain()</li>
<li><code>qtmain.lib</code> is passed to the linked which provides the definition of WinMain().</li>
</ul>


<h2>WinMain provided by SDL</h2>

<p>Now, consider that we have familiar what's happpened in Qt, it's time to go into the SDL.</p>

<h3>WinMain is provided by SDLmain.lib</h3>

<p>Source code is more or less like this
```cpp
/<em> This is where execution begins [console apps] </em>/
int
console_main(int argc, char *argv[])
{
//...</p>

<pre><code>/* Run the application main() code */
status = SDL_main(argc, argv);
</code></pre>

<p>//...
}</p>

<p>/<em> This is where execution begins [windowed apps] </em>/
int WINAPI
WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
{</p>

<pre><code>char **argv;
int argc;
char *cmdline;
</code></pre>

<p>//...</p>

<pre><code>/* Run the main program */
console_main(argc, argv);
</code></pre>

<p>//...
}
```</p>

<p>As we can see, a function named SDL_main() is called by WinMain here, but in where is this function defined?</p>

<p>```cpp SDL_main.h</p>

<h1>define main    SDL_main</h1>

<p>```</p>

<h2>How to solve the confilict between the two WinMain()</h2>

<p>Very interesting ^_^</p>

<ul>
<li>Qt: WinMain() provided by qtmain.lib</li>
<li>SDL: WinMain() provided by SDLmain.lib</li>
<li>Qt: main() is redefined to qMain() for MinGW</li>
<li>SDL: main() is redefined to SDL_main() always</li>
</ul>


<p>Consider that</p>

<ul>
<li>WinMain() in SDLmain.lib provide some initialization for SDL, while WinMain() in qtmain.lib not provide such thing for Qt.</li>
<li>SDLmain is provided for all platform, while qtmain is for Windows only.</li>
</ul>


<p>We tended to use the WinMain() provided by SDLmain.lib instead of qtmain.lib</p>

<p>So we can simply add following line to the .pro file to solve the  <code>_WinMain@16</code> conflict.</p>

<p><code>
win32:QMAKE_LIBS_QT_ENGTRY -= -lqtmain
</code></p>

<p>Though this works very for MSVC, but not that well for MinGW. As this cause macro re-definition, and whether the application can be linked successfully will depend on the order of the headers included.</p>

<p>```cpp
//Qt</p>

<h1>if defined(QT_NEEDS_QMAIN)</h1>

<h1>define main qMain</h1>

<h1>endif</h1>

<p>//SDL</p>

<h1>define main    SDL_main</h1>

<p>```</p>

<p>So another line is needed</p>

<p><code>
win32:QMAKE_LIBS_QT_ENGTRY -= -lqtmain
win32-g++:DEFINES -= QT_NEEDS_QMAIN
</code></p>

<p>or we can disable windows application facility provided by qmake totally, then do it ourself.</p>

<p><code>
CONFIG-= windows
QMAKE_LFLAGS += $$QMAKE_LFLAGS_WINDOWS
</code></p>

<h2>Reference</h2>

<ul>
<li>http://wiki.libsdl.org/moin.fcg/FAQWindows</li>
<li>http://blog.csdn.net/dbzhang800/article/details/6358996</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redirect current process's stdout to a Widget such as QTextEdit]]></title>
    <link href="http://blog.debao.me/2013/07/redirect-current-processs-stdout-to-a-widget-such-as-qtextedit/"/>
    <updated>2013-07-05T17:26:00+08:00</updated>
    <id>http://blog.debao.me/2013/07/redirect-current-processs-stdout-to-a-widget-such-as-qtextedit</id>
    <content type="html"><![CDATA[<p>Note:</p>

<ul>
<li>Source code can be got from https://github.com/dbzhang800/StdoutRedirector</li>
<li>This class can only be used in Qt5, as QWindowsPipeReader which is introduced in Qt5.0 is used.</li>
</ul>


<h2>Implementation</h2>

<h3>Windows</h3>

<ul>
<li>Normally, we need to create pipe with CreatePipe(), then attach stdout to it's write end with SetStdHandle(), then read from pipe's read end with ReadFile().</li>
</ul>


<p>```cpp</p>

<pre><code>createWinPipe(hRead, hWrite);
if (m_channels &amp; StandardOutput)
    ::SetStdHandle(STD_OUTPUT_HANDLE, hWrite);
if (m_channels &amp; StandardError)
    ::SetStdHandle(STD_ERROR_HANDLE, hWrite);
</code></pre>

<p>```</p>

<ul>
<li>But the CRT has already completed initialization before the application gets a chance to call SetStdHandle(); the three low I/O handles 0, 1, and 2 have already been set up to use the original OS handles. So we must deal with this layer using posix api _dup2() too.</li>
</ul>


<p>```cpp</p>

<pre><code>int fd = _open_osfhandle((intptr_t)hWrite, _O_WRONLY|_O_TEXT);
if (m_channels &amp; StandardOutput)
    _dup2(fd, 1);
if (m_channels &amp; StandardError)
    _dup2(fd, 2);
_close(fd);
</code></pre>

<p>```</p>

<ul>
<li>Anonymous pipes created with CreatePipe() do not support asynchronous I/O, so named pipe is used.</li>
</ul>


<p>```cpp
static void createWinPipe(HANDLE &amp;hRead, HANDLE &amp;hWrite)
{</p>

<pre><code>QString pipeName = QString::fromLatin1("\\\\.\\pipe\\stdoutredirector-%1").arg(QUuid::createUuid().toString());
SECURITY_ATTRIBUTES attributes = {sizeof(SECURITY_ATTRIBUTES), 0, false};
hRead = ::CreateNamedPipe((wchar_t*)pipeName.utf16(), PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
                              PIPE_TYPE_BYTE | PIPE_WAIT, 1, 0, 1024 * 1024, 0, &amp;attributes);

SECURITY_ATTRIBUTES attributes2 = {sizeof(SECURITY_ATTRIBUTES), 0, true};
hWrite = ::CreateFile((wchar_t*)pipeName.utf16(), GENERIC_WRITE,
                    0, &amp;attributes2, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);

::ConnectNamedPipe(hRead, NULL);
</code></pre>

<p>}
```</p>

<ul>
<li>QWindowsPipeReader is used to watch the pipe read end.</li>
</ul>


<p>```cpp</p>

<pre><code>pipeReader = new QWindowsPipeReader(this);
pipeReader-&gt;setHandle(hRead);
pipeReader-&gt;startAsyncRead();
connect(pipeReader, SIGNAL(readyRead()), this, SIGNAL(readyRead()));
</code></pre>

<p>```</p>

<h3>Posix</h3>

<ul>
<li>First, we create a pipe, then make the writable end of the pipe the new stdout, and finally, read from the readable part of the pipe.</li>
</ul>


<p>```cpp</p>

<pre><code>::pipe(pipeEnds);
if (m_channels &amp; StandardOutput)
    ::dup2(pipeEnds[1], 1);
if (m_channels &amp; StandardError)
    ::dup2(pipeEnds[1], 2);
::close(pipeEnds[1]);
</code></pre>

<p>```</p>

<ul>
<li>QSocketNotifier is used in order to monitor the activity  of the pipe-read-end.</li>
</ul>


<p>```cpp</p>

<pre><code>socketNotifier = new QSocketNotifier(pipeEnds[0], QSocketNotifier::Read, this);
connect(socketNotifier, SIGNAL(activated(int)), this, SLOT(onSocketActivated()));
</code></pre>

<p>```</p>

<ul>
<li>Note that QSocketNotifier will keep emitting signal if data exists in the pipe, while our readyRead() only emit when new data arrival, so QRingBuffer is used as a buffer.</li>
</ul>


<h2>Issues</h2>

<ul>
<li>[Windows]Can't capture the stdout output generated by another dlls.</li>
</ul>


<p>If the dll compiled with a c/c++ run-time which is different from the run-time used by current application, or the run-time staticly linked to the dll or application, we will encounter this problem.</p>

<p>The reason is that, the DLL grabs the stdout handles when it is loaded, which  took place before we changed the stdout handles. Dynamically load the DLL after changing the stdout handles will be helpful in this case.</p>

<ul>
<li>[Windows]Can't capture the output of qDebug()</li>
</ul>


<p>When the application build as a GUI application(without CONFIG += console in the .pro file), the debug messages will be send to the Debuger using the system api OutputDebugString().</p>

<p><code>
OutputDebugString(reinterpret_cast&lt;const wchar_t *&gt;(logMessage.utf16()));
</code></p>

<p>If <code>CONFIG+=console</code> is added to the .pro file, the debug message will be sent to the stderr.</p>

<p><code>
fprintf(stderr, "%s", logMessage.toLocal8Bit().constData());
</code></p>

<h2>Reference</h2>

<ul>
<li><a href="http://support.microsoft.com/kb/q105305">INFO: Calling CRT Output Routines from a GUI Application </a></li>
<li><a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/redirecting-standard-io.html">Redirecting standard I/O from within a program</a></li>
<li><a href="http://www.halcyon.com/~ast/dload/guicon.htm">Adding Console I/O to a Win32 GUI App</a></li>
<li><a href="http://stackoverflow.com/questions/3202654/will-loading-a-dll-dynamically-reconcile-its-stderr-to-a-main-application-if-so">Will loading a DLL dynamically reconcile its stderr to a main application? If so, then howâ€¦?</a></li>
<li><a href="http://stackoverflow.com/questions/5911147/how-to-redirect-printf-output-back-into-code">How to redirect printf output back into code?</a></li>
<li><a href="http://social.msdn.microsoft.com/Forums/vstudio/en-US/a111b4c6-c491-4586-8fcb-2ad67bfbbae8/is-setstdhandlestdoutputhandle-broken-under-windows-7-">Is SetStdHandle(STD_OUTPUT_HANDLE, ..) broken under windows 7 ?? </a></li>
<li><a href="http://www.adras.com/Redirect-stderr-stdout-to-a-file-using-SetStdHandle.t8132-144.html">Redirect stderr/stdout to a file using SetStdHandle</a></li>
<li><a href="http://fixunix.com/programmer/95541-converting-file*-handle.html">Converting a FILE* to a HANDLE ?</a></li>
<li><a href="http://lists.qt.nokia.com/public/qt-interest/2011-January/030998.html">How to capture stdout and redirect it to the gui?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qt Macro: Q_DECLARE_INTERFACE]]></title>
    <link href="http://blog.debao.me/2013/06/qt-macro-q-declare-interface/"/>
    <updated>2013-06-25T12:34:00+08:00</updated>
    <id>http://blog.debao.me/2013/06/qt-macro-q-declare-interface</id>
    <content type="html"><![CDATA[<h2>Q_DECLARE_INTERFACE(InterfaceClassName, InterfaceId)</h2>

<p>This macro associate the given InterfaceId to the interface class called InterfaceClassName.The macro is normally used right after the interface definition:</p>

<p><code>cpp
class MyInterface {};
Q_DECLARE_INTERFACE(MyInterface, "me.debao.qt.myinterface")
</code></p>

<p>Q_DECLARE_INTERFACE is a macro that defines helper function that make qobject_cast&lt;IFace<em>>(QObject </em>object) return a IFace pointer.
```cpp</p>

<h1>define Q_DECLARE_INTERFACE(IFace, IId) \</h1>

<pre><code>template &lt;&gt; inline const char *qobject_interface_iid&lt;IFace *&gt;() \
{ return IId; } \
template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(QObject *object) \
{ return reinterpret_cast&lt;IFace *&gt;((object ? object-&gt;qt_metacast(IId) : 0)); } \
template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(const QObject *object) \
{ return reinterpret_cast&lt;IFace *&gt;((object ? const_cast&lt;QObject *&gt;(object)-&gt;qt_metacast(IId) : 0)); }
</code></pre>

<p>```</p>

<p>InterfaceId is used in the function <code>QObject::qt_metacast(InterfaceId)</code>. But, how does this function work?</p>

<h2>Q_INTERFACES(...)</h2>

<p>This macro tells Qt which interfaces the class implements.</p>

<p>```cpp
class PluginObject : public QObject, public MyInterface
{</p>

<pre><code>Q_OBJECT
Q_INTERFACES(MyInterface)
</code></pre>

<p>public:</p>

<pre><code>...
</code></pre>

<p>};</p>

<p>```</p>

<p>When moc find Q_INTERFACES, it will generate a function called qt_metacast()</p>

<p>```cpp
void <em>PluginObject::qt_metacast(const char </em>iname)
{</p>

<pre><code>if (strcmp(iname, "PluginObject")==0) return this;
if (strcmp(iname, "MyInterface")==0) return static_cast&lt;MyInterface *&gt;(this);
if (strcmp(iname, "me.debao.qt.myinterface")==0) return static_cast&lt;MyInterface *&gt;(this);
//...
</code></pre>

<p>}
```</p>

<h2>Q_PLUGIN_METADATA ()</h2>

<p>This macro is being used to declare meta data which will be part of plugin. Then these data can be obtained without load the plugin.</p>

<p>```cpp
class PluginObject : public QObject, public MyInterface
{</p>

<pre><code>Q_OBJECT
Q_PLUGIN_METADATA(IID "me.dabao.qt.myinterface" FILE "abc.json")
Q_INTERFACES(MyInterface)
</code></pre>

<p>public:</p>

<pre><code>...
</code></pre>

<p>};
```</p>

<p>When moc encounter the macro, it will generate char array to store the meta data(IID string, FILE contents and other infomation such as QTVERSION) and a macro to export the plugin.</p>

<p>```cpp
static const unsigned char qt_pluginMetaData[] = {</p>

<pre><code>'Q', 'T', 'M', 'E', 'T', 'A', 'D', 'A', 'T', 'A', ' ', ' ',
0x71, 0x62, 0x6a, 0x73, 0x01, 0x00, 0x00, 0x00,
0xe0, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
0xcc, 0x00, 0x00, 0x00, 0x1b, 0x03, 0x00, 0x00,
</code></pre>

<p>//...
};
QT_MOC_EXPORT_PLUGIN(EchoPlugin, EchoPlugin)
<code>
In macro QT_MOC_EXPORT_PLUGIN, two C functions get exported.
</code>cpp</p>

<h1>define Q_PLUGIN_INSTANCE(IMPLEMENTATION) \</h1>

<pre><code>    { \
        static QT_PREPEND_NAMESPACE(QPointer)&lt;QT_PREPEND_NAMESPACE(QObject)&gt; _instance; \
        if (!_instance)      \
            _instance = new IMPLEMENTATION; \
        return _instance; \
    }
</code></pre>

<h1>define QT_MOC_EXPORT_PLUGIN(PLUGINCLASS, PLUGINCLASSNAME)      \</h1>

<pre><code>        Q_EXTERN_C Q_DECL_EXPORT \
        const char *qt_plugin_query_metadata() \
        { return (const char *)qt_pluginMetaData; } \
        Q_EXTERN_C Q_DECL_EXPORT QT_PREPEND_NAMESPACE(QObject) *qt_plugin_instance() \
        Q_PLUGIN_INSTANCE(PLUGINCLASS)
</code></pre>

<p>```</p>

<h2>Reference</h2>

<ul>
<li>http://qt-project.org/wiki/QtPlugins</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qt Macro: Q_DECLARE_METATYPE]]></title>
    <link href="http://blog.debao.me/2013/06/qt-macro-q-declare-metatype/"/>
    <updated>2013-06-21T11:29:00+08:00</updated>
    <id>http://blog.debao.me/2013/06/qt-macro-q-declare-metatype</id>
    <content type="html"><![CDATA[<h2>QMetaType</h2>

<ul>
<li>It associates a type name to a type ID, enabling construction and destruction to occur dynamically at runtime.</li>
<li>QMetaType is used as a helper in QVariant and queued signals and slots connections.</li>
</ul>


<p>```cpp  example1</p>

<h1>include <QtCore></h1>

<p>class MyClass
{
public:</p>

<pre><code>MyClass() {qDebug("Created");}
~MyClass() {qDebug("Destroyed");}
</code></pre>

<p>};</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>int id = qRegisterMetaType&lt;MyClass&gt;("MyClass");

void *myClassPtr = QMetaType::create(id);
QMetaType::destroy(id, myClassPtr);
myClassPtr = 0;
</code></pre>

<p>}</p>

<p>```
and</p>

<p>```cpp example2</p>

<h1>include <QtCore></h1>

<p>class MyClass
{
public:</p>

<pre><code>MyClass() {qDebug("Created");}
MyClass(const MyClass&amp; ){qDebug("Copy");}
~MyClass() {qDebug("Destroyed");}
</code></pre>

<p>};
Q_DECLARE_METATYPE(MyClass)</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>MyClass cls;
QVariant var1 = QVariant::fromValue(cls);
MyClass cls1 = var1.value&lt;MyClass&gt;();
</code></pre>

<p>}
```</p>

<p>The Q_DECLARE_METATYPE() makes the type known to all template based functions, including QVariant. But if we want to use the type in queued signal and slot connections or in QObject's property system, you have to call qRegisterMetaType() since the names are resolved at runtime.</p>

<h2>Q_DECLARE_METATYPE</h2>

<p>This macro is used to specialise the template class QMetaTypeId with typename TYPE, in which, a static member function qt_metatype_id() is defined.</p>

<p>qRegisterMetaType() is called to register the TYPE and generate a TYPE ID. Then the TYPE ID is saved in local static vairable metatype_id.</p>

<p>```cpp</p>

<h1>define Q_DECLARE_METATYPE(TYPE)                                        \</h1>

<pre><code>QT_BEGIN_NAMESPACE                                                  \
template &lt;&gt;                                                         \
struct QMetaTypeId&lt; TYPE &gt;                                          \
{                                                                   \
    enum { Defined = 1 };                                           \
    static int qt_metatype_id()                                     \
        {                                                           \
            static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
            if (const int id = metatype_id.loadAcquire())           \
                return id;                                          \
            const int newId = qRegisterMetaType&lt; TYPE &gt;(#TYPE,      \
                          reinterpret_cast&lt; TYPE *&gt;(quintptr(-1))); \
            metatype_id.storeRelease(newId);                        \
            return newId;                                           \
        }                                                           \
};                                                                  \
QT_END_NAMESPACE
</code></pre>

<p>```</p>

<p>Note that, for Qt's builtin types, <code>Q_DECLARE_BUILTIN_METATYPE</code> instead of <code>Q_DECLARE_METATYPE</code> is used. The ids of these types are constant.
```</p>

<h1>define Q_DECLARE_BUILTIN_METATYPE(TYPE, METATYPEID, NAME) \</h1>

<pre><code>QT_BEGIN_NAMESPACE \
template&lt;&gt; struct QMetaTypeId2&lt;NAME&gt; \
{ \
    enum { Defined = 1, IsBuiltIn = true, MetaType = METATYPEID };   \
    static inline Q_DECL_CONSTEXPR int qt_metatype_id() { return METATYPEID; } \
}; \
QT_END_NAMESPACE
</code></pre>

<p>```
Olivier Goffart said that,
<blockquote><p>I beleive it has been added so adding builting type do not conflicts with<br/>Q_DECLARE_METATYPE of the same type.</p></blockquote></p>

<h2>qRegisterMetaType</h2>

<p>Information of Qt's builtin types is saved in a static global const struct array <code>types[]</code>.</p>

<p>```
static const struct { const char * typeName; int typeNameLength; int type; } types[] = {</p>

<pre><code>//  ...
{0, 0, QMetaType::UnknownType}
</code></pre>

<p>};</p>

<p>```</p>

<p>While the information of the types register through qRegisterMetaType is stored in static QVector with type QCustomTypeInfo
<code>
Q_GLOBAL_STATIC(QVector&lt;QCustomTypeInfo&gt;, customTypes)
</code></p>

<p>The definition of QCustomTypeInfo:</p>

<p>```cpp
class QMetaTypeInterface
{
public:</p>

<pre><code>QMetaType::Creator creator;
QMetaType::Deleter deleter;
QMetaType::SaveOperator saveOp;
QMetaType::LoadOperator loadOp;
QMetaType::Constructor constructor;
QMetaType::Destructor destructor;
int size;
quint32 flags; // same as QMetaType::TypeFlags
const QMetaObject *metaObject;
</code></pre>

<p>};</p>

<p>public:
class QCustomTypeInfo : public QMetaTypeInterface
{
public:</p>

<pre><code>QCustomTypeInfo()
    : alias(-1)
{
    QMetaTypeInterface empty = QT_METATYPE_INTERFACE_INIT(void);
    *static_cast&lt;QMetaTypeInterface*&gt;(this) = empty;
}
QByteArray typeName;
int alias;
</code></pre>

<p>};</p>

<p>```</p>

<h3>qRegisterMetaType() vs qRegisterMetaType(const char *)</h3>

<p>When Call qRegisterMetaType() to register the type T. T must be declared with Q_DECLARE_METATYPE()
As the member function qt_metatype_id() which is expaned from Q_DECLARE_METATYPE will be called in qMetaTypeId<T>().
```
template <typename T>
inline Q_DECL_CONSTEXPR int qRegisterMetaType()
{</p>

<pre><code>return qMetaTypeId&lt;T&gt;();
</code></pre>

<p>}
```
And we can see that, qRegisterMetaType(const char *) is called in qt_metatype_id() too.</p>

<p>```
template <typename T>
int qRegisterMetaType(const char *typeName</p>

<h1>ifndef Q_QDOC</h1>

<pre><code>, T * dummy = 0
, typename QtPrivate::MetaTypeDefinedHelper&lt;T, QMetaTypeId2&lt;T&gt;::Defined &amp;&amp; !QMetaTypeId2&lt;T&gt;::IsBuiltIn&gt;::DefinedType defined = QtPrivate::MetaTypeDefinedHelper&lt;T, QMetaTypeId2&lt;T&gt;::Defined &amp;&amp; !QMetaTypeId2&lt;T&gt;::IsBuiltIn&gt;::Defined
</code></pre>

<h1>endif</h1>

<p>)
{</p>

<pre><code>QT_PREPEND_NAMESPACE(QByteArray) normalizedTypeName = QMetaObject::normalizedType(typeName);
return qRegisterNormalizedMetaType&lt;T&gt;(normalizedTypeName, dummy, defined);
</code></pre>

<p>}
```</p>

<p>Finally, QCustomTypeInfo will be constructed and added to the static QVector.</p>

<p>```</p>

<pre><code>QVector&lt;QCustomTypeInfo&gt; *ct = customTypes();
</code></pre>

<p>//...</p>

<pre><code>        QCustomTypeInfo inf;
        inf.typeName = normalizedTypeName;
        inf.creator = creator;
        inf.deleter = deleter;
        //...
        inf.metaObject = metaObject;
        idx = ct-&gt;size() + User;
        ct-&gt;append(inf);
        return idx;
</code></pre>

<p>```</p>

<h2>pointerToTypeDerivedFromQObject ?</h2>

<p>Q_DECLARE_METATYPE for QObjectDerived class can be omitted. For example,</p>

<p>```</p>

<h1>include <QtCore></h1>

<p>class QObjectDerived : public QObject
{
  Q_OBJECT
};
//Q_DECLARE_METATYPE(QObjectDerived*)</p>

<p>class MyClass
{</p>

<p>};
Q_DECLARE_METATYPE(MyClass*)</p>

<h1>include "main.moc"</h1>

<p>int main()
{</p>

<pre><code>qDebug() &lt;&lt; qMetaTypeId&lt;MyClass*&gt;();
qDebug() &lt;&lt; qMetaTypeId&lt;QObjectDerived*&gt;();

return 0;
</code></pre>

<p>}
```</p>

<p>Here, another internal QMetaTypeId<em> is introduced.
```
template <typename T>
struct QMetaTypeIdQObject&lt;T</em>, /<em> isPointerToTypeDerivedFromQObject </em>/ true>
{</p>

<pre><code>enum {
    Defined = 1
};

static int qt_metatype_id()
{
    static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);
    if (const int id = metatype_id.loadAcquire())
        return id;
    const char * const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(strlen(cName)) + 1);
    typeName.append(cName).append('*');
    const int newId = qRegisterNormalizedMetaType&lt;T*&gt;(
                    typeName,
                    reinterpret_cast&lt;T**&gt;(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
}
</code></pre>

<p>};</p>

<p>```</p>

<h2>Reference</h2>

<ul>
<li><a href="http://lists.qt-project.org/pipermail/development/2012-February/001880.html">[Development] QMetaTypeId and QMetaTypeId2</a></li>
<li><a href="http://steveire.wordpress.com/2011/03/16/implementing-qvariantqmetatype-features-with-template-tricks/">http://steveire.wordpress.com/2011/03/16/implementing-qvariantqmetatype-features-with-template-tricks/</a></li>
<li><a href="http://qt-project.org/wiki/QVariant">http://qt-project.org/wiki/QVariant</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qt Macro: Q_DECLARE_TYPEINFO]]></title>
    <link href="http://blog.debao.me/2013/06/qt-macro-q-declare-typeinfo/"/>
    <updated>2013-06-19T16:45:00+08:00</updated>
    <id>http://blog.debao.me/2013/06/qt-macro-q-declare-typeinfo</id>
    <content type="html"><![CDATA[<h2>Definition</h2>

<p>Q_DECLARE_TYPEINFO is used to specialise a template class called QTypeInfo.</p>

<p>```cpp qtypeinfo.h</p>

<h1>define Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS) \</h1>

<p>class QTypeInfo<TYPE > \
{ \
public: \</p>

<pre><code>enum { \
    isComplex = (((FLAGS) &amp; Q_PRIMITIVE_TYPE) == 0), \
    isStatic = (((FLAGS) &amp; (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), \
    isLarge = (sizeof(TYPE)&gt;sizeof(void*)), \
    isPointer = false, \
    isDummy = (((FLAGS) &amp; Q_DUMMY_TYPE) != 0), \
    sizeOf = sizeof(TYPE) \
}; \
static inline const char *name() { return #TYPE; } \
</code></pre>

<p>}</p>

<h1>define Q_DECLARE_TYPEINFO(TYPE, FLAGS) \</h1>

<p>template&lt;> \
Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS)
```</p>

<h2>Where Q_DECLARE_TYPEINFO is used?</h2>

<p>The documention says that:</p>

<p><blockquote><p>Q_DECLARE_TYPEINFO( Type, Flags)</p></p><p><p>   You can use this macro to specify information about a custom type Type. With accurate type information, Qt's generic containers can choose appropriate storage methods and algorithms.</p></blockquote></p>

<p>Let's find where QTypeInfo is used in Qt's source code:</p>

<p>```cpp qlist.h
template <typename T>
class QList
{</p>

<pre><code>struct Node { void *v;
    Q_INLINE_TEMPLATE T &amp;t()
    { return *reinterpret_cast&lt;T*&gt;(QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic
                                   ? v : this); }
};
</code></pre>

<p>//...
```</p>

<p>```cpp qvector.h
template <typename T>
void QVector<T>::reallocData(const int asize, const int aalloc, QArrayData::AllocationOptions options)
{
//...</p>

<pre><code>            if (QTypeInfo&lt;T&gt;::isStatic || (isShared &amp;&amp; QTypeInfo&lt;T&gt;::isComplex)) {
                // we can not move the data, we need to copy construct it
                while (srcBegin != srcEnd) {
                    new (dst++) T(*srcBegin++);
                }
            } else {
                ::memcpy(static_cast&lt;void *&gt;(dst), static_cast&lt;void *&gt;(srcBegin), (srcEnd - srcBegin) * sizeof(T));
</code></pre>

<p>//...
```</p>

<h2>TYPEINFO flags</h2>

<p>```cpp qtypeinfo.h
enum { /<em> TYPEINFO flags </em>/</p>

<pre><code>Q_COMPLEX_TYPE = 0,
Q_PRIMITIVE_TYPE = 0x1,
Q_STATIC_TYPE = 0,
Q_MOVABLE_TYPE = 0x2,
Q_DUMMY_TYPE = 0x4
</code></pre>

<p>};
```</p>

<ul>
<li>Q_PRIMITIVE_TYPE specifies that Type is a POD (plain old data) type with no constructor or destructor, or else a type where every bit pattern is a valid object and memcpy() creates a valid independent copy of the object.</li>
<li>Q_MOVABLE_TYPE specifies that Type has a constructor and/or a destructor but can be moved in memory using memcpy().</li>
<li>Q_COMPLEX_TYPE (the default) specifies that Type has constructors and/or a destructor and that it may not be moved in memory.</li>
</ul>


<p>For QVector, When an insertion takes place, the elements that come after the point of insertion must be moved one position further. If T is a movable type, this is achieved using memmove(); otherwise, QVector<T> needs to move the items one by one using operator=(). The same applies to removals in the middle.</p>

<p><img class="center" src="/images/blog/2013/q_declare_typeinfo_qvector_insert.png"></p>

<h2>Reference</h2>

<ul>
<li><a href="http://doc.qt.digia.com/qq/qq19-containers.html">http://doc.qt.digia.com/qq/qq19-containers.html</a></li>
<li><a href="http://www.drdobbs.com/c-made-easier-plain-old-data/184401508">http://www.drdobbs.com/c-made-easier-plain-old-data/184401508</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
