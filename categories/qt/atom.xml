<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Qt | 1+1=2]]></title>
  <link href="http://blog.debao.me/categories/qt/atom.xml" rel="self"/>
  <link href="http://blog.debao.me/"/>
  <updated>2013-08-06T17:22:44+08:00</updated>
  <id>http://blog.debao.me/</id>
  <author>
    <name><![CDATA[Debao Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to use QThread in the right way (Part 1)]]></title>
    <link href="http://blog.debao.me/2013/08/how-to-use-qthread-in-the-right-way-part-1/"/>
    <updated>2013-08-05T17:34:00+08:00</updated>
    <id>http://blog.debao.me/2013/08/how-to-use-qthread-in-the-right-way-part-1</id>
    <content type="html"><![CDATA[<h2>A short history</h2>

<p>Long long ago, <strong>subclass QThread and reimplement its run() function</strong> is the only recommended way of using QThread. This is rather intuitive and easy to used. But when SLOTS or Qt Event System are used in the worker thread, some users <a href="http://blog.qt.digia.com/blog/2010/06/17/youre-doing-it-wrong/">do it wrong</a>. So Bradley T. Hughes, one of the Qt core developers, recommend that <strong>use worker objects by moving them to the thread using QObject::moveToThread</strong> . Unfortunately, some users don't understand the relationship of two usages and and some others thought that the former usage is totally wrong. So Olivier Goffart, one of the former Qt core developers, tell the users: <a href="http://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html">You were not doing so wrong</a>. Finally, we can find both usages in the documentation of QThread.</p>

<h2>QThread::run() is the thread entry point</h2>

<p>From the Qt Documentation, we can see that</p>

<blockquote><p>A QThread instance represents a thread and provides the means to start() a thread, which will then execute the reimplementation of QThread::run(). The run() implementation is for a thread what the main() entry point is for the application.</p></blockquote>

<p>As QThread::run() is the thread entry point, it is rather intuitive to use the Usage 1.</p>

<h2>Usage 1-0</h2>

<p>To run some code in a new thread, subclass QThread and reimplement its run() function.</p>

<p>For example</p>

<p>```cpp</p>

<h1>include <QtCore></h1>

<p>class Thread : public QThread
{
private:</p>

<pre><code>void run()
{
    qDebug()&lt;&lt;"From worker thread: "&lt;&lt;currentThreadId();
}
</code></pre>

<p>};</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>QCoreApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();

Thread t;
QObject::connect(&amp;t, SIGNAL(finished()), &amp;a, SLOT(quit()));

t.start();
return a.exec();
</code></pre>

<p>}
```</p>

<p>The output more or less look like:</p>

<pre><code>From main thread:  0x15a8 
From worker thread:  0x128c 
</code></pre>

<h2>Usage 1-1</h2>

<p>As QThread::run() is the thread entry point, so it easy to undersand that, all the codes that are not get called in the run() function directly won't be executed in the worker thread.</p>

<p>In the following example, the member variable <code>m_stop</code> will be operated by both stop() and run(). Consider that the former will be executed in main thread while the latter is executed in worker thread, mutex or other facility is needed.</p>

<p>```cpp</p>

<h1>if QT_VERSION>=0x050000</h1>

<h1>include <QtWidgets></h1>

<h1>else</h1>

<h1>include <QtGui></h1>

<h1>endif</h1>

<p>class Thread : public QThread
{</p>

<pre><code>Q_OBJECT
</code></pre>

<p>public:</p>

<pre><code>Thread():m_stop(false)
{}
</code></pre>

<p>public slots:</p>

<pre><code>void stop()
{
    qDebug()&lt;&lt;"Thread::stop called from main thread: "&lt;&lt;currentThreadId();
    QMutexLocker locker(&amp;m_mutex);
    m_stop=true;
}
</code></pre>

<p>private:</p>

<pre><code>QMutex m_mutex;
bool m_stop;

void run()
{
    qDebug()&lt;&lt;"From worker thread: "&lt;&lt;currentThreadId();
    while (1) {
        {
        QMutexLocker locker(&amp;m_mutex);
        if (m_stop) break;
        }
        msleep(10);
    }
}
</code></pre>

<p>};</p>

<h1>include "main.moc"</h1>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>QApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();
QPushButton btn("Stop Thread");
Thread t;

QObject::connect(&amp;btn, SIGNAL(clicked()), &amp;t, SLOT(stop()));
QObject::connect(&amp;t, SIGNAL(finished()), &amp;a, SLOT(quit()));

t.start();
btn.show();
return a.exec();
</code></pre>

<p>}
```</p>

<p>The output is more or less like</p>

<pre><code>From main thread:  0x13a8 
From worker thread:  0xab8 
Thread::stop called from main thread:  0x13a8
</code></pre>

<p>You can see that the Thread::stop() is executed in the main thread.</p>

<h2>Usage 1-2 (Wrong Usage)</h2>

<p>Though above examples are easy to understand, but it's not so intuitive when event system(or queued-connection) is introduced in worker thread.</p>

<p>For example, what should we do if we want to do something periodly in the worker thread?</p>

<ul>
<li>Create a QTimer in the Thread::run()</li>
<li>Connect the timeout signal to the slot of Thread</li>
</ul>


<p>```cpp</p>

<h1>include <QtCore></h1>

<p>class Thread : public QThread
{</p>

<pre><code>Q_OBJECT
</code></pre>

<p>private slots:</p>

<pre><code>void onTimeout()
{
    qDebug()&lt;&lt;"Thread::onTimeout get called from? : "&lt;&lt;QThread::currentThreadId();
}
</code></pre>

<p>private:</p>

<pre><code>void run()
{
    qDebug()&lt;&lt;"From worker thread: "&lt;&lt;currentThreadId();
    QTimer timer;
    connect(&amp;timer, SIGNAL(timeout()), this, SLOT(onTimeout()));
    timer.start(1000);

    exec();
}
</code></pre>

<p>};</p>

<h1>include "main.moc"</h1>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>QCoreApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();

Thread t;
t.start();

return a.exec();
</code></pre>

<p>}</p>

<p>```</p>

<p>At first glance, the code seems fine. When the thread starts executing, we setup a QTimer thats going to run in the current thread's event queue. We connect the <code>onTimeout()</code>  to the timeout signal. Then we except it works in the worker thread?</p>

<p>But, the result of the example is</p>

<pre><code>From main thread:  0x13a4 
From worker thread:  0x1330 
Thread::onTimeout get called from?:  0x13a4 
Thread::onTimeout get called from?:  0x13a4 
Thread::onTimeout get called from?:  0x13a4 
</code></pre>

<p>Very interesting, isn't it? (We will discuss what happened behined this in next blog)</p>

<h3>How to solve this problem</h3>

<p>In order to make the this SLOT works in the worker thread, some one pass the <code>Qt::DirectConnection</code> to the connect() function,</p>

<p>```cpp</p>

<pre><code>    connect(&amp;timer, SIGNAL(timeout()), this, SLOT(onTimeout()), Qt::DirectConnection);
</code></pre>

<p>```</p>

<p>and some other add following line to the thread constructor.</p>

<p>```cpp</p>

<pre><code>    moveToThread(this)
</code></pre>

<p>```</p>

<p>Both of them work as expected. But ...</p>

<p><a href="http://blog.qt.digia.com/blog/2010/06/17/youre-doing-it-wrong/">The second usage is wrong</a>,</p>

<blockquote><p>Even though this seems to work, itâ€™s confusing, and not how QThread was designed to be used(all of the functions in QThread were written and intended to be called from the creating thread, not the thread that QThread starts)</p></blockquote>

<p>In fact, according to above statements, the first workaround is wrong too. As onTimeout() which is a member of our Thread object, get called from the creating thread too.</p>

<p>Both of them are bad uasge?! what should we do?</p>

<h2>Usage 1-3</h2>

<p>As none of the member of QThread object are designed to be called from the worker thread. So we must create an independent worker object if we want to use SLOTS.</p>

<p>```cpp</p>

<h1>include <QtCore></h1>

<p>class Worker : public QObject
{</p>

<pre><code>Q_OBJECT
</code></pre>

<p>private slots:</p>

<pre><code>void onTimeout()
{
    qDebug()&lt;&lt;"Worker::onTimeout get called from?: "&lt;&lt;QThread::currentThreadId();
}
</code></pre>

<p>};</p>

<p>class Thread : public QThread
{</p>

<pre><code>Q_OBJECT
</code></pre>

<p>private:</p>

<pre><code>void run()
{
    qDebug()&lt;&lt;"From work thread: "&lt;&lt;currentThreadId();
    QTimer timer;
    Worker worker;
    connect(&amp;timer, SIGNAL(timeout()), &amp;worker, SLOT(onTimeout()));
    timer.start(1000);

    exec();
}
</code></pre>

<p>};</p>

<h1>include "main.moc"</h1>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>QCoreApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();

Thread t;
t.start();

return a.exec();
</code></pre>

<p>}
```</p>

<p>The result of the application is</p>

<pre><code>From main thread:  0x810 
From work thread:  0xfac 
Worker::onTimeout get called from?:  0xfac 
Worker::onTimeout get called from?:  0xfac 
Worker::onTimeout get called from?:  0xfac 
</code></pre>

<p>Problem solved now!</p>

<p>Though this works perfect, but you may have notice that, when event loop <code>QThread::exec()</code> is used in the worker thread, the code in the QThread::run() seems has nothing to do with QThread itself.</p>

<p>So can we move the object creation out of the QThread::run(), and at the same time, the slots of they will still be called by the QThread::run()?</p>

<h2>Usage 2-0</h2>

<p>If we only want to make use of QThread::exec(), which has been called by QThread::run() by default, there will be no need to subclass the QThread any more.</p>

<ul>
<li>Create a Worker object</li>
<li>Do signal and slot connections</li>
<li>Move the Worker object to a sub-thread</li>
<li>Start thread</li>
</ul>


<p>```cpp</p>

<h1>include <QtCore></h1>

<p>class Worker : public QObject
{</p>

<pre><code>Q_OBJECT
</code></pre>

<p>private slots:</p>

<pre><code>void onTimeout()
{
    qDebug()&lt;&lt;"Worker::onTimeout get called from?: "&lt;&lt;QThread::currentThreadId();
}
</code></pre>

<p>};</p>

<h1>include "main.moc"</h1>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>QCoreApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();

QThread t;
QTimer timer;
Worker worker;

QObject::connect(&amp;timer, SIGNAL(timeout()), &amp;worker, SLOT(onTimeout()));
timer.start(1000);

timer.moveToThread(&amp;t);
worker.moveToThread(&amp;t);

t.start();

return a.exec();
</code></pre>

<p>}
```</p>

<p>The result is:</p>

<pre><code>From main thread:  0x1310 
Worker::onTimeout get called from?:  0x121c 
Worker::onTimeout get called from?:  0x121c 
Worker::onTimeout get called from?:  0x121c 
</code></pre>

<p>As expected, the slot doesn't run in the main thread.</p>

<p>In this example, both of the QTimer and Worker are moved to the sub-thread. In fact, moving QTimer to sub-thread is not required.</p>

<h1>Usage 2-1</h1>

<p>Simply remove the line <code>timer.moveToThread(&amp;t);</code> from above example will work as expected too.</p>

<p>```cpp
int main(int argc, char *argv[])
{</p>

<pre><code>QCoreApplication a(argc, argv);
qDebug()&lt;&lt;"From main thread: "&lt;&lt;QThread::currentThreadId();

QThread t;
QTimer timer;
Worker worker;

QObject::connect(&amp;timer, SIGNAL(timeout()), &amp;worker, SLOT(onTimeout()));
timer.start(1000);
</code></pre>

<p>//    timer.moveToThread(&amp;t);</p>

<pre><code>worker.moveToThread(&amp;t);

t.start();

return a.exec();
</code></pre>

<p>}
```</p>

<p>The difference is that:</p>

<p>In last example,</p>

<ul>
<li>The signal <code>timeout()</code> is emitted from sub-thread</li>
<li>As timer and worker live in the same thread, their connection type is direct connection.</li>
<li>The slot get called in the same thead in which signal get emitted.</li>
</ul>


<p>While in this example,</p>

<ul>
<li>The signal <code>timeout()</code> emitted from main thread,</li>
<li>As timer and worker live in different threads, their connection type is queued connection.</li>
<li>The slot get called in its living thread, which is the sub-thread.</li>
</ul>


<p>Thanks to a mechanism called queued connections, it is safe to connect signals and slots across different threads. If all the across threads communication are done though queued connections, the usual multithreading precautions such as QMutex will no longer need to be taken.</p>

<h2>In short</h2>

<ul>
<li>Subclass QThread and reimplement its run() function is intuitive and there are still many perfectly valid reasons to subclass QThread, but when event loop is used is worker thread, most user can't do it in the right way.</li>
<li>Use worker objects by moving them to the thread is easy to use when event loop exists, as it has hidden the details of event loop and queued connection.</li>
</ul>


<h2>Reference</h2>

<ul>
<li>http://blog.qt.digia.com/blog/2010/06/17/youre-doing-it-wrong/</li>
<li>http://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html</li>
<li>http://ilearnstuff.blogspot.com/2012/08/when-qthread-isnt-thread.html</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[left shift operator overloading for QDebug()]]></title>
    <link href="http://blog.debao.me/2013/07/left-shift-operator-overloading-for-qdebug/"/>
    <updated>2013-07-16T10:04:00+08:00</updated>
    <id>http://blog.debao.me/2013/07/left-shift-operator-overloading-for-qdebug</id>
    <content type="html"><![CDATA[<p>Consider that we have create a custom type:</p>

<p><code>cpp
struct Point
{
Point(int x, int y):x(x),y(y){}
int x;
int y;
};
</code></p>

<p>If we want to make it work with qDebug(), we need to implement a streaming operator:</p>

<p><code>cpp
QDebug operator&lt;&lt;(QDebug dbg, const Point &amp;p)
</code></p>

<p>But, wait ...</p>

<p>When we using pure c++, what we do is:</p>

<p><code>cpp
ostream &amp;operator&lt;&lt;(ostream &amp;out, const Point &amp;p)
</code></p>

<p><strong>Why QDebug object is passed by value instead of reference?</strong></p>

<h2>qDebug() vs. std::cout</h2>

<p>In first glance, qDebug() is very similiar to std::cout.</p>

<p><code>cpp
qDebug()&lt;&lt;"From Qt qDebug()";
std::cout&lt;&lt;"From C++ std::cout"&lt;&lt;std::endl;
</code></p>

<p>However, each time we call qDebug(), a <em>new</em> <code>QDebug</code> object will be created.</p>

<p><code>cpp
QDebug qDebug() { return QDebug(QtDebugMsg); }
</code></p>

<p>while std::cout is a <em>global</em> <code>std::ostream</code> object, the header file iostream is more or less like this:</p>

<p>```cpp
namespace std
{</p>

<pre><code>extern ostream cout;
static ios_base::Init __ioinit;
</code></pre>

<p>}
```</p>

<h2>Why reference doesn't work for QDebug</h2>

<p>We know that,</p>

<p><code>cpp
qDebug() &lt;&lt; Point(1,2);
</code>
can be wrriten as:</p>

<p><code>cpp
QDebug(QtDebugMsg) &lt;&lt; Point(1,2);
</code></p>

<p>Which can also be wrriten as:</p>

<p><code>cpp
operator &lt;&lt;(QDebug(QtDebugMsg), Point(1,2));
</code></p>

<p>As we can see, a temporary QDebug object is passed to the function in above statements.</p>

<p>But in C++, we know that,</p>

<blockquote><p>A temporary cannot be bound to a non-const reference.</p></blockquote>

<p>That why</p>

<p>```cpp
QDebug operator&lt;&lt;(QDebug dbg, const Point &amp;p)</p>

<p>```
should be used instead of</p>

<p><code>cpp
QDebug &amp; operator&lt;&lt;(QDebug &amp;dbg, const Point &amp;p)
</code></p>

<h2>Problem?</h2>

<p>Some one complain that, though</p>

<p><code>cpp
QDebug &amp; operator&lt;&lt;(QDebug &amp;dbg, const Point &amp;p)
</code></p>

<p>doesn't work for <code>qDebug()&lt;&lt;Point(1,2);</code>, but it  indeed works for <code>qDebug()&lt;&lt;""&lt;&lt;Point(1,2);</code>. Why?</p>

<p>The latter statement can be re-written as</p>

<p><code>cpp
operator &lt;&lt;(QDebug(QtDebugMsg).operator &lt;&lt;(""), Point(1,2));
</code></p>

<p>and note that, QDebug has provided the member function for type <code>char *</code>:</p>

<p><code>cpp
QDebug &amp; QDebug::operator&lt;&lt;(const char * s);
</code></p>

<p>in which a reference to current QDebug object is return.</p>

<p>So C++ compiler will be happy with this now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Link Confilict between SDL and Qt under Windows]]></title>
    <link href="http://blog.debao.me/2013/07/link-confilict-between-sdl-and-qt-under-windows/"/>
    <updated>2013-07-09T09:22:00+08:00</updated>
    <id>http://blog.debao.me/2013/07/link-confilict-between-sdl-and-qt-under-windows</id>
    <content type="html"><![CDATA[<p>Someone complain that, when using SDL and Qt in the same project under Windows, the linker will generate link error.</p>

<blockquote><p>SDLmain.lib(SDL_win32_main.obj):-1: error: LNK2005: _WinMain@16 already defined in qtmaind.lib(qtmain_win.obj)</p></blockquote>

<p>What happened behined this?</p>

<p>```</p>

<h1>include <QApplication></h1>

<h1>include &lt;SDL.h></h1>

<p>int main(int argc, char** argv)
{
return 0;
}
```</p>

<h2>WinMain vs main</h2>

<p>The C and C++ standards require any program to have a function called <em>main</em>, which serves as the program's startup function. It can have one of the following signatures:</p>

<p><code>
int main()
int main(int argc, char* argv[])
</code></p>

<p>However, <em>WinMain</em> is selected by Microsoft as the conventional name used for the GUI application entry point.</p>

<p><code>
int CALLBACK WinMain(
  _In_  HINSTANCE hInstance,
  _In_  HINSTANCE hPrevInstance,
  _In_  LPSTR lpCmdLine,
  _In_  int nCmdShow
);
</code></p>

<p>As a crossplatform library, both SDL and Qt don't require user to use the <em>WinMain</em> function to create GUI application for Windows. Instead, they both provided a <strong>WinMain()</strong> for us.</p>

<h2>WinMain provided by Qt</h2>

<h3>qtmain.lib provided by Qt</h3>

<p>As a Qt developer, we all know that, when ceating a GUI application under windows. qtmain.lib(or libqtmain.a) will be linked to the application.</p>

<p>If we open the source file of the library, we can see that our <em>main()</em> entry is called by a wrapped function WinMain()</p>

<p>```cpp  %QTDIR%/src/winmain/qtmain_win.cpp
/<em>
  WinMain() - Initializes Windows and calls user's startup function main().
  NOTE: WinMain() won't be called if the application was linked as a "console"
  application.
</em>/</p>

<p>extern "C"
int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prevInstance, LPSTR, int cmdShow)
{
...</p>

<pre><code>int result = main(argc, argv.data());
</code></pre>

<p>...
}
```</p>

<p>Very insteresting, isn't it? But</p>

<h3>This work well for MSVC though, but not for MinGW</h3>

<p>Consider we have a simple windows application which contians both main() and WinMain()</p>

<p>```cpp</p>

<h1>include &lt;windows.h></h1>

<p>int main()
{
  MessageBoxW (NULL, L"Hello World from main!", L"hello", MB_OK | MB_ICONINFORMATION);
  return 0;
}</p>

<p>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPTSTR lpCmdLine, int nShowCmd)
{
  MessageBoxW (NULL, L"Hello World from WinMain!", L"hello", MB_OK | MB_ICONINFORMATION);
  return 0;
}
<code>
* For MSVC, WinMain() or main() will be used depending on whether</code>/entry:WinMainCRTStartup``` is passed to the linker or not.
* For MinGW, WinMain() will never be called if main() exists!</p>

<h3>How to solve this problem for MinGW</h3>

<p>Let's see what happened when build a Qt Gui application under Windows.</p>

<p>In Qt souce file qwindowdefs.h or qtmain_win.cpp, we can find following code.
```cpp</p>

<h1>if defined(QT_NEEDS_QMAIN)</h1>

<h1>define main qMain</h1>

<h1>endif</h1>

<p>```</p>

<p>So <em>main()</em> doesn't exist any more when QT_NEEDS_QMAIN is defined!</p>

<h3>What happened for Gui Application?</h3>

<p>We know that,</p>

<p><code>
CONFIG += windows
</code>
is the default config of qmake, and that's why we have to add</p>

<p><code>
CONFIG += console
</code></p>

<p>if when want to create a mormal console application.</p>

<p>The former will force the qmake to load a feature file called <em>windows.prf</em>, in which we can find fowllowing code:</p>

<p>```
CONFIG -= console
contains(TEMPLATE, ".*app"){</p>

<pre><code>QMAKE_LFLAGS += $$QMAKE_LFLAGS_WINDOWS
win32-g++:DEFINES += QT_NEEDS_QMAIN
win32-borland:DEFINES += QT_NEEDS_QMAIN

qt:for(entryLib, $$list($$unique(QMAKE_LIBS_QT_ENTRY))) {
    isEqual(entryLib, -lqtmain): {
        CONFIG(debug, debug|release): QMAKE_LIBS += $${entryLib}$${QT_LIBINFIX}d
        else: QMAKE_LIBS += $${entryLib}$${QT_LIBINFIX}
    } else {
        QMAKE_LIBS += $${entryLib}
    }
}
</code></pre>

<p>}
```
As you can see, three things done here:</p>

<ul>
<li>Windows subsystem instead of console subsystem is linked, so no black-cmd-window will be shown when the application running. Note that, <code>$$QMAKE_LFLAGS_WINDOWS</code> will be expanded to <code>/subsystem:windows</code> or <code>-Wl,-subsystem,windows</code>.</li>
<li><code>QT_NEEDS_QMAIN</code> is defined for MinGW, so main() will be renamed to qMain which will be called by WinMain()</li>
<li><code>qtmain.lib</code> is passed to the linked which provides the definition of WinMain().</li>
</ul>


<h2>WinMain provided by SDL</h2>

<p>Now, consider that we have familiar what's happpened in Qt, it's time to go into the SDL.</p>

<h3>WinMain is provided by SDLmain.lib</h3>

<p>Source code is more or less like this
```cpp
/<em> This is where execution begins [console apps] </em>/
int
console_main(int argc, char *argv[])
{
//...</p>

<pre><code>/* Run the application main() code */
status = SDL_main(argc, argv);
</code></pre>

<p>//...
}</p>

<p>/<em> This is where execution begins [windowed apps] </em>/
int WINAPI
WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
{</p>

<pre><code>char **argv;
int argc;
char *cmdline;
</code></pre>

<p>//...</p>

<pre><code>/* Run the main program */
console_main(argc, argv);
</code></pre>

<p>//...
}
```</p>

<p>As we can see, a function named SDL_main() is called by WinMain here, but in where is this function defined?</p>

<p>```cpp SDL_main.h</p>

<h1>define main    SDL_main</h1>

<p>```</p>

<h2>How to solve the confilict between the two WinMain()</h2>

<p>Very interesting ^_^</p>

<ul>
<li>Qt: WinMain() provided by qtmain.lib</li>
<li>SDL: WinMain() provided by SDLmain.lib</li>
<li>Qt: main() is redefined to qMain() for MinGW</li>
<li>SDL: main() is redefined to SDL_main() always</li>
</ul>


<p>Consider that</p>

<ul>
<li>WinMain() in SDLmain.lib provide some initialization for SDL, while WinMain() in qtmain.lib not provide such thing for Qt.</li>
<li>SDLmain is provided for all platform, while qtmain is for Windows only.</li>
</ul>


<p>We tended to use the WinMain() provided by SDLmain.lib instead of qtmain.lib</p>

<p>So we can simply add following line to the .pro file to solve the  <code>_WinMain@16</code> conflict.</p>

<p><code>
win32:QMAKE_LIBS_QT_ENGTRY -= -lqtmain
</code></p>

<p>Though this works very for MSVC, but not that well for MinGW. As this cause macro re-definition, and whether the application can be linked successfully will depend on the order of the headers included.</p>

<p>```cpp
//Qt</p>

<h1>if defined(QT_NEEDS_QMAIN)</h1>

<h1>define main qMain</h1>

<h1>endif</h1>

<p>//SDL</p>

<h1>define main    SDL_main</h1>

<p>```</p>

<p>So another line is needed</p>

<p><code>
win32:QMAKE_LIBS_QT_ENGTRY -= -lqtmain
win32-g++:DEFINES -= QT_NEEDS_QMAIN
</code></p>

<p>or we can disable windows application facility provided by qmake totally, then do it ourself.</p>

<p><code>
CONFIG-= windows
QMAKE_LFLAGS += $$QMAKE_LFLAGS_WINDOWS
</code></p>

<h2>Reference</h2>

<ul>
<li>http://wiki.libsdl.org/moin.fcg/FAQWindows</li>
<li>http://blog.csdn.net/dbzhang800/article/details/6358996</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redirect current process's stdout to a Widget such as QTextEdit]]></title>
    <link href="http://blog.debao.me/2013/07/redirect-current-processs-stdout-to-a-widget-such-as-qtextedit/"/>
    <updated>2013-07-05T17:26:00+08:00</updated>
    <id>http://blog.debao.me/2013/07/redirect-current-processs-stdout-to-a-widget-such-as-qtextedit</id>
    <content type="html"><![CDATA[<p>Note:</p>

<ul>
<li>Source code can be got from https://github.com/dbzhang800/StdoutRedirector</li>
<li>This class can only be used in Qt5, as QWindowsPipeReader which is introduced in Qt5.0 is used.</li>
</ul>


<h2>Implementation</h2>

<h3>Windows</h3>

<ul>
<li>Normally, we need to create pipe with CreatePipe(), then attach stdout to it's write end with SetStdHandle(), then read from pipe's read end with ReadFile().</li>
</ul>


<p>```cpp</p>

<pre><code>createWinPipe(hRead, hWrite);
if (m_channels &amp; StandardOutput)
    ::SetStdHandle(STD_OUTPUT_HANDLE, hWrite);
if (m_channels &amp; StandardError)
    ::SetStdHandle(STD_ERROR_HANDLE, hWrite);
</code></pre>

<p>```</p>

<ul>
<li>But the CRT has already completed initialization before the application gets a chance to call SetStdHandle(); the three low I/O handles 0, 1, and 2 have already been set up to use the original OS handles. So we must deal with this layer using posix api _dup2() too.</li>
</ul>


<p>```cpp</p>

<pre><code>int fd = _open_osfhandle((intptr_t)hWrite, _O_WRONLY|_O_TEXT);
if (m_channels &amp; StandardOutput)
    _dup2(fd, 1);
if (m_channels &amp; StandardError)
    _dup2(fd, 2);
_close(fd);
</code></pre>

<p>```</p>

<ul>
<li>Anonymous pipes created with CreatePipe() do not support asynchronous I/O, so named pipe is used.</li>
</ul>


<p>```cpp
static void createWinPipe(HANDLE &amp;hRead, HANDLE &amp;hWrite)
{</p>

<pre><code>QString pipeName = QString::fromLatin1("\\\\.\\pipe\\stdoutredirector-%1").arg(QUuid::createUuid().toString());
SECURITY_ATTRIBUTES attributes = {sizeof(SECURITY_ATTRIBUTES), 0, false};
hRead = ::CreateNamedPipe((wchar_t*)pipeName.utf16(), PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
                              PIPE_TYPE_BYTE | PIPE_WAIT, 1, 0, 1024 * 1024, 0, &amp;attributes);

SECURITY_ATTRIBUTES attributes2 = {sizeof(SECURITY_ATTRIBUTES), 0, true};
hWrite = ::CreateFile((wchar_t*)pipeName.utf16(), GENERIC_WRITE,
                    0, &amp;attributes2, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);

::ConnectNamedPipe(hRead, NULL);
</code></pre>

<p>}
```</p>

<ul>
<li>QWindowsPipeReader is used to watch the pipe read end.</li>
</ul>


<p>```cpp</p>

<pre><code>pipeReader = new QWindowsPipeReader(this);
pipeReader-&gt;setHandle(hRead);
pipeReader-&gt;startAsyncRead();
connect(pipeReader, SIGNAL(readyRead()), this, SIGNAL(readyRead()));
</code></pre>

<p>```</p>

<h3>Posix</h3>

<ul>
<li>First, we create a pipe, then make the writable end of the pipe the new stdout, and finally, read from the readable part of the pipe.</li>
</ul>


<p>```cpp</p>

<pre><code>::pipe(pipeEnds);
if (m_channels &amp; StandardOutput)
    ::dup2(pipeEnds[1], 1);
if (m_channels &amp; StandardError)
    ::dup2(pipeEnds[1], 2);
::close(pipeEnds[1]);
</code></pre>

<p>```</p>

<ul>
<li>QSocketNotifier is used in order to monitor the activity  of the pipe-read-end.</li>
</ul>


<p>```cpp</p>

<pre><code>socketNotifier = new QSocketNotifier(pipeEnds[0], QSocketNotifier::Read, this);
connect(socketNotifier, SIGNAL(activated(int)), this, SLOT(onSocketActivated()));
</code></pre>

<p>```</p>

<ul>
<li>Note that QSocketNotifier will keep emitting signal if data exists in the pipe, while our readyRead() only emit when new data arrival, so QRingBuffer is used as a buffer.</li>
</ul>


<h2>Issues</h2>

<ul>
<li>[Windows]Can't capture the stdout output generated by another dlls.</li>
</ul>


<p>If the dll compiled with a c/c++ run-time which is different from the run-time used by current application, or the run-time staticly linked to the dll or application, we will encounter this problem.</p>

<p>The reason is that, the DLL grabs the stdout handles when it is loaded, which  took place before we changed the stdout handles. Dynamically load the DLL after changing the stdout handles will be helpful in this case.</p>

<ul>
<li>[Windows]Can't capture the output of qDebug()</li>
</ul>


<p>When the application build as a GUI application(without CONFIG += console in the .pro file), the debug messages will be send to the Debuger using the system api OutputDebugString().</p>

<p><code>
OutputDebugString(reinterpret_cast&lt;const wchar_t *&gt;(logMessage.utf16()));
</code></p>

<p>If <code>CONFIG+=console</code> is added to the .pro file, the debug message will be sent to the stderr.</p>

<p><code>
fprintf(stderr, "%s", logMessage.toLocal8Bit().constData());
</code></p>

<h2>Reference</h2>

<ul>
<li><a href="http://support.microsoft.com/kb/q105305">INFO: Calling CRT Output Routines from a GUI Application </a></li>
<li><a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/redirecting-standard-io.html">Redirecting standard I/O from within a program</a></li>
<li><a href="http://www.halcyon.com/~ast/dload/guicon.htm">Adding Console I/O to a Win32 GUI App</a></li>
<li><a href="http://stackoverflow.com/questions/3202654/will-loading-a-dll-dynamically-reconcile-its-stderr-to-a-main-application-if-so">Will loading a DLL dynamically reconcile its stderr to a main application? If so, then howâ€¦?</a></li>
<li><a href="http://stackoverflow.com/questions/5911147/how-to-redirect-printf-output-back-into-code">How to redirect printf output back into code?</a></li>
<li><a href="http://social.msdn.microsoft.com/Forums/vstudio/en-US/a111b4c6-c491-4586-8fcb-2ad67bfbbae8/is-setstdhandlestdoutputhandle-broken-under-windows-7-">Is SetStdHandle(STD_OUTPUT_HANDLE, ..) broken under windows 7 ?? </a></li>
<li><a href="http://www.adras.com/Redirect-stderr-stdout-to-a-file-using-SetStdHandle.t8132-144.html">Redirect stderr/stdout to a file using SetStdHandle</a></li>
<li><a href="http://fixunix.com/programmer/95541-converting-file*-handle.html">Converting a FILE* to a HANDLE ?</a></li>
<li><a href="http://lists.qt.nokia.com/public/qt-interest/2011-January/030998.html">How to capture stdout and redirect it to the gui?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qt Macro: Q_DECLARE_INTERFACE]]></title>
    <link href="http://blog.debao.me/2013/06/qt-macro-q-declare-interface/"/>
    <updated>2013-06-25T12:34:00+08:00</updated>
    <id>http://blog.debao.me/2013/06/qt-macro-q-declare-interface</id>
    <content type="html"><![CDATA[<h2>Q_DECLARE_INTERFACE(InterfaceClassName, InterfaceId)</h2>

<p>This macro associate the given InterfaceId to the interface class called InterfaceClassName.The macro is normally used right after the interface definition:</p>

<p><code>cpp
class MyInterface {};
Q_DECLARE_INTERFACE(MyInterface, "me.debao.qt.myinterface")
</code></p>

<p>Q_DECLARE_INTERFACE is a macro that defines helper function that make qobject_cast&lt;IFace<em>>(QObject </em>object) return a IFace pointer.
```cpp</p>

<h1>define Q_DECLARE_INTERFACE(IFace, IId) \</h1>

<pre><code>template &lt;&gt; inline const char *qobject_interface_iid&lt;IFace *&gt;() \
{ return IId; } \
template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(QObject *object) \
{ return reinterpret_cast&lt;IFace *&gt;((object ? object-&gt;qt_metacast(IId) : 0)); } \
template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(const QObject *object) \
{ return reinterpret_cast&lt;IFace *&gt;((object ? const_cast&lt;QObject *&gt;(object)-&gt;qt_metacast(IId) : 0)); }
</code></pre>

<p>```</p>

<p>InterfaceId is used in the function <code>QObject::qt_metacast(InterfaceId)</code>. But, how does this function work?</p>

<h2>Q_INTERFACES(...)</h2>

<p>This macro tells Qt which interfaces the class implements.</p>

<p>```cpp
class PluginObject : public QObject, public MyInterface
{</p>

<pre><code>Q_OBJECT
Q_INTERFACES(MyInterface)
</code></pre>

<p>public:</p>

<pre><code>...
</code></pre>

<p>};</p>

<p>```</p>

<p>When moc find Q_INTERFACES, it will generate a function called qt_metacast()</p>

<p>```cpp
void <em>PluginObject::qt_metacast(const char </em>iname)
{</p>

<pre><code>if (strcmp(iname, "PluginObject")==0) return this;
if (strcmp(iname, "MyInterface")==0) return static_cast&lt;MyInterface *&gt;(this);
if (strcmp(iname, "me.debao.qt.myinterface")==0) return static_cast&lt;MyInterface *&gt;(this);
//...
</code></pre>

<p>}
```</p>

<h2>Q_PLUGIN_METADATA ()</h2>

<p>This macro is being used to declare meta data which will be part of plugin. Then these data can be obtained without load the plugin.</p>

<p><strong>NOTE: The plugin IID has nothing todo with the INTERFACES IID.</strong></p>

<p>```cpp
class PluginObject : public QObject, public MyInterface
{</p>

<pre><code>Q_OBJECT
Q_PLUGIN_METADATA(IID "me.dabao.qt.myplugin" FILE "abc.json")
Q_INTERFACES(MyInterface)
</code></pre>

<p>public:</p>

<pre><code>...
</code></pre>

<p>};
```</p>

<p>When moc encounter the macro, it will generate char array to store the meta data(IID string, FILE contents and other infomation such as QTVERSION) and a macro to export the plugin.</p>

<p>```cpp
static const unsigned char qt_pluginMetaData[] = {</p>

<pre><code>'Q', 'T', 'M', 'E', 'T', 'A', 'D', 'A', 'T', 'A', ' ', ' ',
0x71, 0x62, 0x6a, 0x73, 0x01, 0x00, 0x00, 0x00,
0xe0, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
0xcc, 0x00, 0x00, 0x00, 0x1b, 0x03, 0x00, 0x00,
</code></pre>

<p>//...
};
QT_MOC_EXPORT_PLUGIN(EchoPlugin, EchoPlugin)
<code>
In macro QT_MOC_EXPORT_PLUGIN, two C functions get exported.
</code>cpp</p>

<h1>define Q_PLUGIN_INSTANCE(IMPLEMENTATION) \</h1>

<pre><code>    { \
        static QT_PREPEND_NAMESPACE(QPointer)&lt;QT_PREPEND_NAMESPACE(QObject)&gt; _instance; \
        if (!_instance)      \
            _instance = new IMPLEMENTATION; \
        return _instance; \
    }
</code></pre>

<h1>define QT_MOC_EXPORT_PLUGIN(PLUGINCLASS, PLUGINCLASSNAME)      \</h1>

<pre><code>        Q_EXTERN_C Q_DECL_EXPORT \
        const char *qt_plugin_query_metadata() \
        { return (const char *)qt_pluginMetaData; } \
        Q_EXTERN_C Q_DECL_EXPORT QT_PREPEND_NAMESPACE(QObject) *qt_plugin_instance() \
        Q_PLUGIN_INSTANCE(PLUGINCLASS)
</code></pre>

<p>```</p>

<h3>Magic in moc</h3>

<p>All the magic of this macro can be found in the source code of moc:</p>

<p>```cpp
void Generator::generatePluginMetaData()
{</p>

<pre><code>if (cdef-&gt;pluginData.iid.isEmpty())
    return;

// Write plugin meta data #ifdefed QT_NO_DEBUG with debug=false,
// true, respectively.

QJsonObject data;
const QString debugKey = QStringLiteral("debug");
data.insert(QStringLiteral("IID"), QLatin1String(cdef-&gt;pluginData.iid.constData()));
data.insert(QStringLiteral("className"), QLatin1String(cdef-&gt;classname.constData()));
data.insert(QStringLiteral("version"), (int)QT_VERSION);
data.insert(debugKey, QJsonValue(false));
data.insert(QStringLiteral("MetaData"), cdef-&gt;pluginData.metaData.object());

fputs("\nQT_PLUGIN_METADATA_SECTION const uint qt_section_alignment_dummy = 42;\n\n"
      "#ifdef QT_NO_DEBUG\n", out);
writePluginMetaData(out, data);

fputs("\n#else // QT_NO_DEBUG\n", out);

data.remove(debugKey);
data.insert(debugKey, QJsonValue(true));
writePluginMetaData(out, data);

fputs("#endif // QT_NO_DEBUG\n\n", out);

// 'Use' all namespaces.
int pos = cdef-&gt;qualified.indexOf("::");
for ( ; pos != -1 ; pos = cdef-&gt;qualified.indexOf("::", pos + 2) )
    fprintf(out, "using namespace %s;\n", cdef-&gt;qualified.left(pos).constData());
fprintf(out, "QT_MOC_EXPORT_PLUGIN(%s, %s)\n\n",
        cdef-&gt;qualified.constData(), cdef-&gt;classname.constData());
</code></pre>

<p>}
```</p>

<p>All the data can be retrieved through QPluginLoader before we really load the library.</p>

<p><code>cpp
QJsonObject QPluginLoader::metaData() const
</code></p>

<p>For example:</p>

<p>```cpp</p>

<pre><code>    QPluginLoader pluginLoader(fileName);
    QString iid = pluginLoader.metaData().value("IID").toString();
    if (iid == "my_plugin_iid") {
        pluginLoader.load();
        //...
    }
</code></pre>

<p>```</p>

<h2>Reference</h2>

<ul>
<li>http://qt-project.org/wiki/QtPlugins</li>
</ul>

]]></content>
  </entry>
  
</feed>
